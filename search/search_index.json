{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"1. Introduction","text":"<p>This codespace is powered by the Dynatrace Enablement Framework, this means that this codespace:</p> <ul> <li>can run in github codespaces, as a remote container or locally as docker container</li> <li>is crosscompiled for AMD and ARM architectures</li> <li>follows a set of standards and best practices for enhancing the user experience</li> </ul> <p>Want to learn more about it? We invite you to read this documentation</p> <p> </p>"},{"location":"#project-goals","title":"Project Goals","text":"The goal of this effort <p>Reduce complexity, remove friction and increase adoption of the Dynatrace Platform</p> <p>The Dynatrace Enablement Framework is a structured set of tooling and best practices designed to streamline how we deliver, maintain, and scale solutions across the Dynatrace Platform. Its core purpose is to increase platform adoption by ensuring consistent training delivery, comprehensive solution coverage, and operational efficiency.Trainings within the framework are built as GitHub Codespaces\u2014they\u2019re publicly accessible, run seamlessly across environments, and adhere to a defined set of standards to ensure quality, repeatability, and alignment across teams.</p>"},{"location":"#dynatrace-enablement-framework-in-a-nutshell","title":"Dynatrace Enablement Framework in a Nutshell","text":"<p>The Dynatrace Enablement Framework streamlines the delivery of demos and hands-on trainings for the Dynatrace Platform. It provides a unified set of tools, templates, and best practices to ensure trainings are easy to create, run anywhere, and maintain over time.</p>"},{"location":"#key-features","title":"\u2705 Key Features","text":"<ul> <li> <p>GitHub-Hosted &amp; Versioned   All trainings are managed in GitHub repositories, ensuring traceability and collaboration.</p> </li> <li> <p>Self-Service Documentation   Each repo includes its own MkDocs-powered documentation, published via GitHub Pages.</p> </li> <li> <p>Universal Base Image   A Docker image supports AMD/ARM architectures, GitHub Codespaces, VS Code Dev Containers, and contaninerized execution in any Ubuntu OS.</p> </li> <li> <p>Separation of Concerns   Modular design allows repo-specific logic without impacting the core framework.</p> </li> <li> <p>Automated Testing   GitHub Actions enable end-to-end integration tests for all trainings.</p> </li> <li> <p>Monitoring &amp; Analytics   Usage and adoption are tracked with Dynatrace for continuous improvement.</p> </li> <li> <p>Rapid Training Creation   Templates and automation help trainers launch new enablement content quickly.</p> </li> <li> <p>Centralised Maintenance   The Codespaces Synchronizer tool keeps all repositories up to date with the latest framework changes.</p> </li> </ul>"},{"location":"#benefits","title":"Benefits","text":"<ul> <li>Reduces complexity and friction for trainers and learners  </li> <li>Increases adoption and consistency  </li> <li>Scales across internal, partner, and customer enablement</li> </ul> <p>What will we do</p> <p>In this tutorial we will learn how easy it is to create an enablement using codespaces and a Kubernetes cluster!</p>"},{"location":"#support-policy","title":"Support Policy","text":"<p>Support Policy</p> <p>This is an enablement project created by the Center of Excellence - Enablement Team at Dynatrace.</p> <p>Support is provided via GitHub issues only. The materials provided in this repository are offered \"as-is\" without any warranties, express or implied. Use them at your own risk.</p> <ul> <li>Yes! let's begin </li> </ul>"},{"location":"cleanup/","title":"Cleanup","text":"<p>Deleting the codespace from inside the container</p> <p>We like to make your life easier, for convenience there is a function loaded in the shell of the Codespace for deleting the codespace, just type <code>deleteCodespace</code>. This will trigger the deletion of the codespace.</p> <p>Another way to do this is by going to https://github.com/codespaces and delete the codespace.</p> <p>You may also want to deactivate or delete the API token needed for this lab.</p> <ul> <li>Ressources</li> </ul>"},{"location":"container-image/","title":"2. Container image","text":""},{"location":"container-image/#overview","title":"Overview","text":"<p>The Dynatrace Enablement Framework uses a custom Docker image as the foundation for all training and demo environments. This image is designed for maximum compatibility, flexibility, and ease of use across different platforms and deployment scenarios.</p>"},{"location":"container-image/#key-features","title":"Key Features","text":""},{"location":"container-image/#base-image","title":"\ud83d\uddbc\ufe0f Base Image:","text":"<p>The framework uses <code>mcr.microsoft.com/devcontainers/base:ubuntu</code> as its base image, ensuring seamless compatibility with GitHub Codespaces and Visual Studio Code Dev Containers.</p>"},{"location":"container-image/#cross-platform-support","title":"\ud83d\udcbb Cross-Platform Support:","text":"<p>The image is built to run on both AMD and ARM architectures, eliminating vendor lock-in and enabling use on a wide range of hardware.</p>"},{"location":"container-image/#local-and-cloud-execution","title":"\u2601\ufe0f Local and Cloud Execution:","text":"<ul> <li>Can be run in GitHub Codespaces for cloud-based development.</li> <li>Supports local execution on Windows, Linux, and macOS via Multipass, providing a consistent development environment regardless of the host OS.</li> </ul>"},{"location":"container-image/#dynatrace-integration","title":"Dynatrace Integration:","text":"<p>Dynatrace OneAgent FullStack and Kubernetes CloudNativeFullstack deployments work seamlessly with this deployment. All necessary components such as the CSI Driver, Webhook, ActiveGate, and OneAgents can be deployed in this image ensuring seamless monitoring and observability of the running applications.</p>"},{"location":"container-image/#tooling","title":"Tooling","text":"<p>\ud83d\udee0\ufe0f Included tooling </p> <p>The image comes with a comprehensive set of tools required for modern DevOps and cloud-native development, including:</p> <ul> <li>Helm</li> <li>Kubectl</li> <li>Kind</li> <li>Docker</li> <li>NodeJs</li> <li>K9s</li> <li>Python</li> </ul>"},{"location":"container-image/#docker-in-socket-strategy","title":"Docker-in-Socket Strategy","text":"<p>The Dynatrace Enablement Framework uses a Docker-in-Socket strategy to enable container management from within the development container. This approach allows the container to communicate directly with the Docker daemon running on the host machine by mounting the Docker socket (<code>/var/run/docker.sock</code>) into the container.</p>"},{"location":"container-image/#how-it-works","title":"How It Works","text":"<ul> <li>The <code>entrypoint.sh</code> script inside the container handles the logic for interacting with the Docker daemon.</li> <li>By sharing the Docker socket, the container can run Docker commands as if it were running directly on the host.</li> <li>This enables workflows such as building, running, and managing additional containers from within your Codespace or Dev Container.</li> </ul>"},{"location":"container-image/#benefits","title":"Benefits","text":"<ul> <li>Consistency: Ensures that Docker commands behave the same way inside the container as they do on the host.</li> <li>Flexibility: Supports advanced scenarios like running nested containers or orchestrating multi-container setups.</li> <li>Simplicity: No need to install Docker separately inside the container; it leverages the host\u2019s Docker installation.</li> </ul>"},{"location":"container-image/#example","title":"Example","text":"<p>In the <code>devcontainer.json</code>, the Docker socket is typically mounted like this:</p> <pre><code>  \"mounts\": [\"source=/var/run/docker.sock,target=/var/run/docker.sock,type=bind\"],\n</code></pre>"},{"location":"container-image/#special-container-runtime-arguments","title":"Special Container Runtime Arguments","text":"<p>The following <code>runArgs</code> configuration is used in the <code>devcontainer.json</code> file to enhance the capabilities of the development container:</p> <pre><code>\"runArgs\": [\"--init\", \"--privileged\", \"--network=host\"]\n</code></pre> <ul> <li>--init: Runs an init process inside the container to handle reaping zombie processes and signal forwarding, improving container stability.</li> <li>--privileged: Grants the container extended privileges, allowing it to access all devices on the host and perform operations typically restricted in standard containers. This is useful for scenarios that require low-level system access (e.g., running Docker inside Docker or accessing host resources).</li> <li>--network=host: Shares the host\u2019s networking stack with the container, enabling the container to use the host\u2019s network interfaces directly. This is helpful for networking tests or when services inside the container need to be accessible on the host network.</li> </ul>"},{"location":"container-image/#image-distribution","title":"Image Distribution","text":"<p>The image is hosted on Docker Hub and is crosscompiled for ARM and AMD architectures. </p>"},{"location":"container-image/#using-the-image-in-devcontainerjson","title":"Using the Image in devcontainer.json","text":"<p>The way you configure your development container depends on whether you want to use the pre-built image or build it yourself from a Dockerfile.</p>"},{"location":"container-image/#using-the-pre-built-image","title":"Using the Pre-built Image","text":"<p>To use the pre-built image, specify the \"image\" property in your devcontainer.json file:</p> <p><pre><code>  // Pulling the image from the Dockerhub, runs on AMD64 and ARM64. Pulling is normally faster.\n  \"image\":\"shinojosa/dt-enablement:v1.1\",\n</code></pre> This will pull the published image from Docker Hub and use it as the base for your Codespace or Dev Container.</p>"},{"location":"container-image/#building-the-image-with-vs-code","title":"Building the Image with VS Code","text":"<p>If you want to build the image yourself (for example, to customise it), you need to use the \"build\" section in your devcontainer.json. Uncomment or add the following: <pre><code>  // \"image\": \"shinojosa/dt-enablement\",  \n  \"build\": {    \n    \"dockerfile\": \"Dockerfile\"  }\n    },\n</code></pre></p> <p>Comment out or remove the \"image\" line. Uncomment or add the \"build\" section, pointing to your Dockerfile. This will instruct the environment to build the image locally using your Dockerfile.</p>"},{"location":"container-image/#cross-compiling-with-buildx","title":"Cross-Compiling with Buildx","text":"<p>In the <code>.devcontainer</code> folder, there is a <code>Makefile</code> that includes a <code>buildx</code> target specifically designed for cross-compiling the container image.</p> <p>To use cross-compilation:</p> <ul> <li>Make sure your host architecture is ARM.</li> <li>Run the <code>buildx</code> target from the <code>Makefile</code> to build the image for multiple architectures.</li> </ul> <p>Example usage:</p>"},{"location":"container-image/#make-buildx","title":"<pre><code>make buildx\n</code></pre>","text":"<ul> <li>Let's continue</li> </ul>"},{"location":"draft/","title":"Draft","text":"<p>Requirements</p> <ul> <li>A Grail enabled Dynatrace SaaS Tenant (sign up here).</li> <li>A GitHub account to interact with the demo repository.</li> </ul> <p>This section is a WIP</p> <p>This section is a WIP</p> <p></p> <p>This section is a WIP</p> <p>This section is a WIP</p> <ul> <li>Let's start our enablement</li> </ul> <ul> <li>Let's launch Codespaces </li> </ul>"},{"location":"framework/","title":"5. The Framework","text":""},{"location":"framework/#5-the-framework","title":"5. The Framework","text":"<p>This section is a WIP</p> <p>This section is a WIP</p> <ul> <li>Let's continue</li> </ul>"},{"location":"instantiation-types/","title":"3. Instantiation types","text":"<p>Choose the option that best fits your needs! \ud83d\ude80</p> <p>The Dynatrace Enablement Framework supports multiple ways to instantiate your development environment, making it flexible for any workflow or platform.  </p>"},{"location":"instantiation-types/#how-to-run-in","title":"\ud83c\udfc3\ud83c\udffb\u200d\u2642\ufe0f How to run in...","text":""},{"location":"instantiation-types/#github-codespaces","title":"\u2601\ufe0f GitHub Codespaces","text":"<ul> <li>  In the repository hosted in github, click on the &lt;&gt; Code button. Create a new codespace using the main branch or click + New with options to customize how and where to run the Codespace within Github Cloud. </li> <li>Secrets (<code>DT_TENANT</code>, <code>DT_OPERATOR_TOKEN</code>, <code>DT_INGEST_TOKEN</code>) are injected automatically using GitHub Codespaces secrets.</li> <li>No manual setup required\u2014these are available as environment variables inside the container.</li> </ul> <p>Protip: Run in any \u2601\ufe0f cloud provider of your choice</p> <p>For VS Code Dev Containers and Local Container you'll need to provide the infrastructure. You can run the enablements in any cloud provider of your choice. For best compatibility we recommend you to spin a VM with an Ubuntu Operating System. Then do a remote connection via VS Code for instantiating VS Code Dev Container or via SSH to run as a Local Container. </p>"},{"location":"instantiation-types/#vs-code-dev-containers","title":"\ud83d\udda5\ufe0f VS Code Dev Containers","text":"<ul> <li>Clone the repository to your local machine (Ubuntu OS recommended for best compatibility).</li> <li>Add a .env file and and adapt the <code>devcontainer.json</code> to read the secrets from the environment and not from the secrets section.</li> <li>In this framework, secrets are passed as environment variables using <code>runArgs</code> in <code>.devcontainer/devcontainer.json</code>:     <pre><code>\"runArgs\": [\"--init\", \"--privileged\", \"--network=host\", \"--env-file\", \".devcontainer/runlocal/.env\"]\n</code></pre></li> <li>This ensures all variables in <code>.devcontainer/runlocal/.env</code> are available inside the container.</li> <li>Open the folder in VS Code and use the Dev Containers extension to \"Reopen in Container\". VS Code will use the <code>.devcontainer/devcontainer.json</code> definition to build and start the environment for you.</li> <li>You can rebuild the container at any time by typing <code>[CTRL] + Shift P &gt; Dev Containers: Rebuild and reopen in container</code></li> </ul>"},{"location":"instantiation-types/#local-container","title":"\ud83d\udc33 Local Container","text":"<ul> <li>Clone the repository to your local machine (Ubuntu OS recommended for best compatibility).</li> <li>Open a terminal in the <code>.devcontainer</code> folder and run:     <pre><code>make start\n</code></pre></li> <li>This will build and launch the container, or attach to it if already running. All ports, volumes, and environment variables are set up automatically.</li> <li>Secrets and environment variables are loaded from <code>.devcontainer/runlocal/.env</code>. </li> <li>The devcontainer.json file is not used with this set-up. Arguments, volume mounts, port-forwarding is handled in the <code>makefile.sh</code></li> <li>The <code>makefile.sh</code> script passes the variables to Docker at runtime.</li> <li>For more details, see the Local Container Details section below.</li> </ul>"},{"location":"instantiation-types/#instantiation-types","title":"Instantiation Types","text":""},{"location":"instantiation-types/#github-codespaces_1","title":"\u2601\ufe0f GitHub Codespaces","text":"<ul> <li>One-click cloud dev environments </li> <li>No local setup required\u2014just click  </li> <li>Learn more about Codespaces</li> </ul>"},{"location":"instantiation-types/#vs-code-dev-containers_1","title":"\ud83d\udda5\ufe0f VS Code Dev Containers","text":"<ul> <li>Use the Dev Containers extension for a seamless local experience in VS Code</li> <li>All configuration is in <code>.devcontainer/devcontainer.json</code></li> <li>Supports secrets, port forwarding, and post-create hooks</li> </ul>"},{"location":"instantiation-types/#local-container_1","title":"\ud83d\udc33 Local Container","text":"<ul> <li>Run the same environment on your machine using Docker.</li> <li>Easiest way: just run <code>make start</code> in the <code>.devcontainer</code> folder.</li> <li>This will build and launch the container if needed, or attach to it if already running.</li> <li>All ports, volumes, and environment variables are set up for you automatically.</li> </ul> <p>See Local Container Details below for a full explanation of how this works.</p>"},{"location":"instantiation-types/#quick-comparison","title":"\u26a1 Quick Comparison","text":"Type Runs On VS Code Needed Fast Start Customizable Secrets Handling Port Forwarding Best For \u2601\ufe0f Codespaces GitHub Cloud \u274c \u2705 \u274c Auto-injected Auto Quick onboarding, demos \ud83d\udda5\ufe0f VS Code DevContainer Provided Infrastructure \u2705 \u2705 \u2705 Auto/manual Auto Full-featured local dev \ud83d\udc33 Local Container Provided Infrastructure \u274c \u2705 \u2705 Manual/<code>.env</code> Manual/Makefile Reproducible local dev"},{"location":"instantiation-types/#secrets-environment","title":"\ud83d\udd10 Secrets &amp; Environment","text":"<p>Secrets and environment variables are handled differently depending on the instantiation type:</p> Instantiation Type How Secrets Are Provided Where to Configure/Set Notes \u2601\ufe0f Codespaces Auto-injected as environment variables from GitHub Codespaces secrets GitHub repository &gt; Codespaces secrets No manual setup; secrets available at container start \ud83d\udda5\ufe0f VS Code Dev Containers Passed as environment variables via <code>runArgs</code> and <code>.env</code> file <code>.devcontainer/devcontainer.json</code>, <code>.devcontainer/runlocal/.env</code> Edit/add <code>.devcontainer/runlocal/.env</code> for local secrets; <code>runArgs</code> must include <code>--env-file</code> \ud83d\udc33 Local Container Loaded from <code>.devcontainer/runlocal/.env</code> file and passed to Docker at runtime by <code>makefile.sh</code> <code>.devcontainer/runlocal/.env</code>, <code>makefile.sh</code> Run <code>make start</code> in <code>.devcontainer</code>; secrets loaded at container start"},{"location":"instantiation-types/#example-runlocalenv-file","title":"Example: <code>runlocal/.env</code> file","text":"<pre><code># Environment variables\n\n# Mapping of the Secrets defined in the .devcontainer.json file\n# Dynatrace Tenant\nDT_TENANT=https://abc123.live.dynatrace.com\n#Description: eg. abc123 for live -&gt; https://abc123.live.dynatrace.com or sprint -&gt; https://abc123.sprint.dynatracelabs.com no apps in the URL\n\n# Dynatrace Operator Token\nDT_OPERATOR_TOKEN=dt0c01.XXXXXX\n#it will be created automatically when adding a new Cluster over the UI. It contains the following permissions: 'Create ActiveGate tokens' 'Read entities' 'Read settings' 'Write settings' 'Access probrem and event feed, metrics and topology' 'PaaS Integration - installer download\n\n#Dynatrace Ingest Token\nDT_INGEST_TOKEN=dt0c01.YYYYYY\n# it will be created automatically when adding a new Cluster over the UI. It contains the following permissions: 'Ingest logs' 'Ingest metrics' 'Ingest OpenTelemetry traces'\n\n# Add any other environment variables as needed\n</code></pre>"},{"location":"instantiation-types/#running-locally","title":"Running locally","text":""},{"location":"instantiation-types/#using-multipass-for-local-development","title":"Using Multipass for Local Development","text":"<p>Multipass is a lightweight VM manager from Canonical that makes it easy to launch and manage Ubuntu virtual machines on macOS, Windows, and Linux. This is especially useful if you want to run the framework in a clean, reproducible Ubuntu environment without dual-booting or using a full desktop VM.</p> <p>Why use Multipass?</p> <ul> <li>Ensures compatibility with Ubuntu-based dev containers and scripts</li> <li>Isolates your development environment from your host OS</li> <li>Quick to launch, easy to reset or remove</li> </ul>"},{"location":"instantiation-types/#basic-usage","title":"Basic usage","text":"<ul> <li>Install Multipass (instructions) </li> <li>Launch an Ubuntu VM: <pre><code>multipass launch --name dt-dev --disk 20G --mem 4G\nmultipass shell dt-dev\n</code></pre></li> </ul>"},{"location":"instantiation-types/#set-up-your-environment","title":"Set up your environment","text":"<pre><code>- Inside the VM, install Docker and git:\n  ```sh\n  sudo apt update &amp;&amp; sudo apt install -y docker.io git\n  sudo usermod -aG docker $USER\n  ```\n- Clone your repository and proceed with the [Local Container](#local-container) or [VS Code Dev Containers](#vs-code-dev-containers) setup as described above.\n</code></pre> <p>Mounting Volumes on Multipass</p> <p>You can mount folders from your host into the VM using <code>multipass mount</code> if you want to edit code locally but run containers in the VM. For example in the following example we are creating a VM mounting the folder <code>enablement</code> where you have all repositories of the enablement framework you want to use.  <pre><code>multipass launch --name enablement --disk 30G --cpus 8 --memory 32G --mount  /Users/sergio.hinojosa/repos/enablement:/home/ubuntu/enablement\n</code></pre></p>"},{"location":"instantiation-types/#local-container-details","title":"Local Container Details","text":"<p>The <code>make start</code> command is the recommended way to launch your local development container. Here\u2019s what happens under the hood:</p> <ul> <li>The <code>Makefile</code> defines a <code>start</code> target, which sources <code>makefile.sh</code> and calls the <code>start</code> function.</li> <li>The <code>start</code> function:<ul> <li>Checks if the container (<code>dt-enablement</code>) is running:<ul> <li>If running, attaches a new shell to it (like creating more Terminals on VS Code).</li> <li>If stopped, removes and recreates the container.</li> <li>If the image is missing, builds it and then runs the container.</li> </ul> </li> <li>All required ports, volumes, and environment variables are set up automatically.</li> <li>The container is started with the correct working directory and post-create/start scripts, just like in Codespaces or Dev Containers.</li> </ul> </li> </ul> <ul> <li>Let's continue</li> </ul>"},{"location":"monitoring/","title":"9. Monitoring","text":""},{"location":"monitoring/#9-monitoring","title":"9. Monitoring","text":"<p>This section is a WIP</p> <p>This section is a WIP</p> <ul> <li>Let's continue</li> </ul>"},{"location":"resources/","title":"10. Resources","text":""},{"location":"resources/#get-your-dynatrace-environment","title":"Get your Dynatrace environment","text":"<ul> <li>Create a Free Trial in Dynatrace</li> </ul>"},{"location":"resources/#documentation","title":"Documentation","text":"<ul> <li>Dynatrace documentation</li> </ul>"},{"location":"resources/#dynatrace-news","title":"Dynatrace news","text":"<ul> <li>Dynatrace Blog</li> </ul> <ul> <li>What's Next? </li> </ul>"},{"location":"synchronizer/","title":"7. Synchronizer","text":""},{"location":"synchronizer/#7-synchronizer","title":"7. Synchronizer","text":"<p>This section is a WIP</p> <p>This section is a WIP</p> <ul> <li>Let's continue</li> </ul>"},{"location":"template/","title":"4. Codespaces Template","text":"<p>The Enablement Codespaces Template is a ready-to-use GitHub repository designed to help you create, customize, and deliver hands-on enablements using GitHub Codespaces. It provides a robust starting point for professors, trainers, and solution architects to build interactive learning environments with minimal setup.</p>"},{"location":"template/#what-is-the-codespaces-template","title":"\ud83d\ude80 What is the Codespaces Template?","text":"<p>This template repository provides:</p> <ul> <li>A pre-configured <code>.devcontainer</code> for instant Codespaces launches</li> <li>Example documentation and structure for enablement content</li> <li>GitHub Actions for CI/CD and documentation deployment</li> <li>Integration with Dynatrace and other cloud-native tools</li> <li>A clean starting point for your own enablement projects</li> </ul>"},{"location":"template/#repository-overview","title":"\ud83d\udce6 Repository Overview","text":"<p>Main features:</p> <ul> <li>.devcontainer/: All configuration for Codespaces and local dev containers</li> <li>docs/: MkDocs-based documentation, ready to extend</li> <li>.github/workflows/: CI/CD for integration tests and GitHub Pages deployment</li> <li>README.md: Project overview and quickstart</li> <li>mkdocs.yaml: Navigation and site configuration</li> </ul> <p>For a full file/folder breakdown, see the repository on GitHub.</p>"},{"location":"template/#how-to-use-the-template","title":"\ud83d\udcdd How to Use the Template","text":"<ol> <li>Create your own enablement repository<ul> <li>Click \"Use this template\" on the GitHub repo</li> <li>Name your new repository and clone it locally</li> </ul> </li> <li>Customize the content<ul> <li>Edit the <code>docs/</code> folder to add your enablement instructions, labs, and resources</li> <li>Update <code>.devcontainer/devcontainer.json</code> to add dependencies or secrets as needed</li> </ul> </li> <li>Launch in Codespaces<ul> <li>Click the Code button in your repo and select \"Open with Codespaces\"</li> <li>Your environment will be ready in seconds, with all tools and docs pre-installed</li> </ul> </li> <li>Publish documentation<ul> <li>The <code>installMKdocs</code> function installs MkDocs inside the container and serves the documentation locally on port 8000, making it easy and enjoyable to write and preview your documentation without hassle.</li> <li>Push changes to <code>main</code> to trigger GitHub Pages deployment (see Actions tab)</li> <li>Your docs will be live at <code>https://&lt;your-org&gt;.github.io/&lt;your-repo&gt;/</code></li> </ul> </li> </ol>"},{"location":"template/#todos-in-the-codebase","title":"\ud83d\udcdd TODOs in the Codebase","text":"<p>Throughout the template repository, you will find <code>TODO</code> comments in various files. These are designed to guide you step-by-step as you create your own enablements\u2014reminding you where to add content, configure secrets, or customize scripts.</p> <p>Tip: To make working with TODOs easier, install a TODO highlighting extension in VS Code, such as TODO Highlight or TODO Tree. These extensions help you quickly find and manage all TODOs in your project.</p> <p>By following and resolving these TODOs, you can efficiently adapt the template to your specific enablement scenario.</p>"},{"location":"template/#who-is-this-for","title":"\ud83e\uddd1\u200d\ud83c\udfeb Who is this for?","text":"<ul> <li>Professors and trainers creating hands-on labs</li> <li>Solution architects building demo environments</li> <li>Anyone who wants a fast, reproducible Codespaces-based enablement</li> </ul>"},{"location":"template/#documentation-resources","title":"\ud83d\udcda Documentation &amp; Resources","text":"<ul> <li>Template Repository</li> <li>How to use the codespaces template</li> </ul> <ul> <li>Let's continue</li> </ul>"},{"location":"testing/","title":"8. Testing","text":""},{"location":"testing/#8-testing","title":"8. Testing","text":"<p>This section is a WIP</p> <p>This section is a WIP</p> <ul> <li>Let's continue</li> </ul>"},{"location":"user-experience/","title":"6. User Experience","text":""},{"location":"user-experience/#6-user-experience","title":"6. User Experience","text":"<p>This section is a WIP</p> <p>This section is a WIP</p> <ul> <li>Let's continue</li> </ul>"},{"location":"whats-next/","title":"11. What's next?","text":"<p>More to come</p> <ul> <li>Stay tuned, more enablements are coming whith more advanced usecases...</li> </ul>"},{"location":"snippets/admonitions/","title":"Admonitions","text":"<p>Note</p> <p>This is a Note </p> <p>Abstract</p> <p>This is an abstract</p> <p>Tipp</p> <p>This is a tipp </p> <p>Success</p> <p>This is a success </p> <p>Question</p> <p>This is a success </p> <p>Failure</p> <p>This is a failure </p> <p>Danger</p> <p>This is a danger </p> <p>Info</p> <p>This is a info</p> <p>Warning</p> <p>This is a Warning </p> <p>This is an Example admonition</p> <p>This is an example</p> This is a bug and is collapsable <p>This is a bug</p>"},{"location":"snippets/disclaimer/","title":"Disclaimer","text":"<p>Support Policy</p> <p>This is an enablement project created by the Center of Excellence - Enablement Team at Dynatrace.</p> <p>Support is provided via GitHub issues only. The materials provided in this repository are offered \"as-is\" without any warranties, express or implied. Use them at your own risk.</p>"},{"location":"snippets/dt-enablement/","title":"Dt enablement","text":"<p>This codespace is powered by the Dynatrace Enablement Framework, this means that this codespace:</p> <ul> <li>can run in github codespaces, as a remote container or locally as docker container</li> <li>is crosscompiled for AMD and ARM architectures</li> <li>follows a set of standards and best practices for enhancing the user experience</li> </ul> <p>Want to learn more about it? We invite you to read this documentation</p>"},{"location":"snippets/grail-requirements/","title":"Grail requirements","text":"<p>Requirements</p> <ul> <li>A Grail enabled Dynatrace SaaS Tenant (sign up here).</li> <li>A GitHub account to interact with the demo repository.</li> </ul>"},{"location":"snippets/view-code/","title":"View code","text":"<p>View the Code</p> <p>The code for this repository is hosted on GitHub. Click the \"View Code on GitHub\" link above.</p>"}]}